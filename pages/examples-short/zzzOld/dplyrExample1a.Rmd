---
title: "dplyr: Example 1 (update)"
author: "Derek H. Ogle"
date: "Sunday, September 28, 2014"
output: html_document
---

```{r setup, echo=FALSE, results='hide'}
library(knitr)
# Having this separate from the setup file allows one to knit this in RStudio.
knit_hooks$set(par1 = function(before, options, envir) {
  if (before) par(mar=c(3.5,3.5,2,2),mgp=c(2.1,0.4,0),tcl=-0.2)
})
opts_chunk$set(dev="png",tidy=FALSE,par1=TRUE)
```


## Note
**I am [reposting this from before](http://fishr.wordpress.com/2014/04/17/dplyr-example-1/), but updated with the new pipe operator from dplyr (i.e., `%>%` rather than `%.%`).**


## Introduction
[Hadley Wickam](http://had.co.nz/) released the **dplyr** package in [January 2014](http://blog.rstudio.org/2014/01/17/introducing-dplyr/).  Since then I have been itching to give it a try as it has been suggested to speed up some data manipulations and, more important to me, provide a singular framework for a variety of common data manipulations.  Recently, I gave it a try with some simple common manipulations for fisheries work.  Below are my examples.

First, the **dplyr** package, **plotrix** (for the plot at the end), and the **FSAdata** package (for the data file) must be loaded.

```{r results='hide', warning=FALSE, message=FALSE}
library(dplyr)
library(FSAdata)
library(plotrix)
```

The `RuffeSLRH92` data frame is then loaded.
```{r}
data(RuffeSLRH92)
str(RuffeSLRH92)
```

## Select (columns) Example
Columns can be selected from a data.frame with `select()`, given the original data.frame as the first argument and the variables to select, or include, as further arguments.  The following creates a data.frame without the `fish.id`, `indiv`, `day`, and `year` variables (they are not very useful in this context and will make the output further below easier to read).
```{r}
RuffeSLRH92 <- select(RuffeSLRH92,-c(fish.id,indiv,day,year))
head(RuffeSLRH92)
```

The following creates a data.frame of just the length and weight variables.
```{r}
ruffeLW <- select(RuffeSLRH92,length,weight)
head(ruffeLW)
```

The **dplyr** package contains a variety of helpers for selecting.  As one example, the following will select all variables that contains the letter "l".
```{r}
ruffeL <- select(RuffeSLRH92,contains("l"))
str(ruffeL)
```


## Filtering Example
The `filter()` function can be used similarly to `subset()` to select a set of rows from an original data.frame according to some conditioning statement.  As with `subset()`, `filter()` returns an object that maintains a list of the original levels whether those levels exist in the new data.frame or not.  Use `droplevels()` to restrict the levels to only those that exist in the data.frame.  The example below finds just the males from the original data.frame.
```{r}
male <- filter(RuffeSLRH92,sex=="male")
xtabs(~sex,data=male)
male <- droplevels(male)
xtabs(~sex,data=male)
```

Multiple conditioning statements can be strung together as additional arguments to `filter()`.  The example below finds males that are also ripe.
```{r}
maleripe <- filter(RuffeSLRH92,sex=="male",maturity=="ripe")
xtabs(~sex+maturity,data=maleripe)
```

So far, it seems that an "or" needs to be completed as with `subset()`.  For example, the following selects those fish that are male or are ripe.
```{r}
maleripe2 <- filter(RuffeSLRH92,sex=="male" | maturity=="ripe")
xtabs(~sex+maturity,data=maleripe2)
```

## Arrange Example
The `arrange()` function can be used to order individuals.  The first argument is the data.frame and the following arguments are the variables to sort by.  The following sorts, in ascending order, the male data.frame created above by length.
```{r}
malea <- arrange(male,length)
head(malea)
tail(malea)
```

The following does the same but in descending order.
```{r}
maled <- arrange(male,desc(length))
head(maled)
tail(maled)
```

Multiple levels of ordering can be completed by including multiple variables as arguments to `arrange()`.  The following sorts the data by ascending length and then ascending weight.
```{r}
ruffe2 <- arrange(RuffeSLRH92,length,weight)
head(ruffe2)
tail(ruffe2)
```

## Add new variables (i.e., columns) Example
The `mutate() function can be used to add new variables to a data.frame.  It requires the original data.frame as the first argument and then arguments to create new variables as the remaining arguments.  The example below adds the natural log of length and weight to the data.frame created above that contains just the length and weight variables.
```{r}
ruffeLW <- mutate(ruffeLW,logL=log(length),logW=log(weight))
head(ruffeLW)
```

## Aggregation and Summarization Example
The **dplyr** package also provides functions that allow for simple aggregation of results.  The `group_by()` function first sets up how you want to group your data.  In the code below, the `byMon` data.frame is going to create groups by the `month` variable.  The `summarize()` function will then summarize a data.frame by the functions after the first argument.  The package also provides `n()` to count the number of individuals.  Thus, the example below will count the number of ruffe in the original data.frame by each month.
```{r}
byMon <- group_by(RuffeSLRH92,month)
( sumMon <- summarize(byMon,count=n()) )
```

The following counts the number of ruffe by each month and sex.
```{r}
byMonSex <- group_by(RuffeSLRH92,month,sex)
( sumMonSex <- summarize(byMonSex,count=n()))
```

Multiple functions can be used to create multiple summaries at once.  The following summarizes the number of fish and the mean and standard deviation of length by month.
```{r}
( LenSumMon <- summarize(byMon,n=n(),mn=mean(length),sd=sd(length)) )
```

## Putting It All Together
Finally, all of the functions described above can be strung together with the `%>%` operator.  This is best shown with an example.  The following set of code will compute the proportion of all captured fish captured in each month by (1) grouping the data by month, (2) summarizing the number per month, (3) adding a new variable that is the proportion of the total catch in each month, and then (4) sorting the results such that the month with the largest catch is listed first.
```{r}
fnl1 <- RuffeSLRH92 %>%
  group_by(month) %>%
  summarize(n=n()) %>%
  mutate(prop.catch=n/sum(n)) %>%
  arrange(desc(prop.catch))
fnl1
```

The following example constructs a data.frame (that is then used to construct a plot) that contains the mean, sd, se, and approximate 95% confidence interval for length by month.
```{r RuffeMeanLength}
fnl2 <- RuffeSLRH92 %>%
  group_by(month) %>%
  summarize(n=n(),mn=mean(length),sd=sd(length)) %>%
  mutate(se=sd/sqrt(n),LCI=mn+qnorm(0.025)*se,UCI=mn+qnorm(0.975)*se)
fnl2
with(fnl2,plotCI(month,mn,ui=UCI,li=LCI,pch=16,ylab="Length (mm)",xlab="Month"))
```

## Final Thoughts
The **dplyr** package appears to have many more useful functions.  This first foray suggests to me that it is going to be a useful "grammar" for simplifying data manipulations.  I will post more as I explore it more.  In the meantime, let me know what your experience with **dplyr** is.

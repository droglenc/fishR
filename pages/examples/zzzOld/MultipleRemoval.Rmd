```{r postblog, eval=FALSE, echo=FALSE}
## Run these commands when you are ready to push out to the fishR blog.
title <- "Multiple Removal Estimates at Once"
cats <- c('Removal','Depletion','Abundance')
keys <- c('Abundance','Removal','Depletion')
setwd("C:/aaaWork/Web/fishR/BlogExamples")
source('WPSetup.R')
knit2wp("MultipleRemoval.Rmd",publish=FALSE,shortcode=TRUE,
        title=title,categories=cats,mt_keywords=keys)
```

```{r setup, echo=FALSE, results='hide'}
# Having this separate from the setup file allows one to knit this in RStudio.
opts_chunk$set(dev="png",tidy=FALSE)
```

# A Question #
Recently, a fishR user asked me the following question:

> I have recently used the FSA package to calculate Zippin depletion population estimates resulting from 3 pass removals on smaller trout streams.  I have currently been doing this the "long way":

```{r longway, eval=FALSE}
##GRYSUS2012
GRYSUS2012 <- c(31,23,9)
a <- removal(GRYSUS2012)
summary(a)
confint(a)

##GRYSUS2013
GRYSUS2013 <- c(60,12,9)
b <- removal(GRYSUS2013)
summary(b)
confint(b)


##GRYSDS2012
GRYSDS2012<- c(45,12,8)
c <- removal(GRYSDS2012)
summary(c)
confint(c)
```

> However, I was wondering if there was a way I could format my data (in tabular format) so that I may run zippin estimates on large numbers of sites at once, using a table similar to the one shown below (Note: I deleted this table but it looks like the data frame in the code below)?  Any help you can provide is much appreciated.  Thanks!

# An Answer #
There is a similar example at the very bottom of the help page for `removal()`, though that example is more complicated.  Here is an answer to this question.

Begin by loading the **FSA** package ...


```{r results='hide', warning=FALSE, message=FALSE}
library(FSA)
```

... and reading in an external tab-delimited text file that simply contains the table that the questioner provided ...

```{r}
( df <- read.table("shanktest.txt",header=TRUE) )
```

Using `apply()` once can send each row of the data frame to `removal()`.  The tricks here are that the first column of `df` must be excluded (hence the `-1` in the square brackets) and `removal()` should return just the parameter estimates (i.e., the use of `just.ests=TRUE`; see the help for `removal()`). 

```{r}
( res <- apply(df[,-1],MARGIN=1,FUN=removal,just.ests=TRUE) )
```

The resulting matrix, however, should be transposed so that the parameter estimates form the columns and the original groupings will form the rows.  In addition, the matrix should be converted to a data frame so that the group names can be appended.

```{r}
( res <- data.frame(t(res)) )
```

The original groupings (from the first column of `df`) can then be appended to make the results more clear.

```{r}
( res <- cbind(site=df[,1],res))
```

Finally, the approximate 95% CIs can be appended.

```{r}
res$No.LCI <- res$No-1.96*res$No.se
res$No.UCI <- res$No+1.96*res$No.se
```

The resulting data frame contains the required information.

```{r}
res
```

# A Modified Answer #
I suppose the questioner could wrap all of this into a function to make the call very easy (though this is not a very general function).

```{r}
multRemoval <- function(df,colwgrp,type) {
  # df is dataframe with the pass data in columns, groups in rows
  # colwgrp is the column numbers with the group names
  # type is the type of calculation to use (see removal())
  tmp <- apply(df[,-colwgrp],MARGIN=1,FUN=removal,type=type,just.ests=TRUE)
  tmp <- data.frame(t(tmp))
  tmp <- cbind(df[,colwgrp],tmp)
  names(tmp)[1] <- names(df)[colwgrp]
  tmp$No.LCI <- tmp$No-1.96*tmp$No.se
  tmp$No.UCI <- tmp$No+1.96*tmp$No.se
  tmp
}

multRemoval(df,1,"Zippin")
```
